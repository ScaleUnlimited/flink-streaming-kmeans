package com.scaleunlimited.flinksources;

import org.apache.flink.api.common.functions.RuntimeContext;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.java.typeutils.ResultTypeQueryable;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.runtime.state.FunctionInitializationContext;
import org.apache.flink.runtime.state.FunctionSnapshotContext;
import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;
import org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction;
import org.apache.flink.streaming.api.functions.source.RichSourceFunction;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.streaming.api.watermark.Watermark;
import org.apache.flink.types.Either;
import org.apache.flink.util.Preconditions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A source that will sequentially work its way through two sources, one at a time. 
 * This lets you do things like  load configuration data into a function before
 * processing other data that is being joined with/processed using this data.
 * 
 * We support a "terminator class" so that workflows with iterations can control
 * how long the source continues to run, as otherwise once a source is exhausted
 * Flink will no longer save checkpoints.
 *
 * @param <T0> - type of data generated by first source.
 * @param <T1> - type of data generated by second source.
 */
@SuppressWarnings("serial")
public class UnionedSources<T0, T1> extends RichParallelSourceFunction<Either<T0, T1>> implements ResultTypeQueryable<Either<T0, T1>>, CheckpointedFunction {
    private static final Logger LOGGER = LoggerFactory.getLogger(UnionedSources.class);

    private TypeInformation<Either<T0, T1>> type;
    private SourceFunction<T0> source0;
    private SourceFunction<T1> source1;
    private SourceTerminator terminator;
    
    private volatile transient boolean isRunning;
    private transient int sourceId;
    private transient boolean checkpointed;

    public UnionedSources(TypeInformation<Either<T0, T1>> type, SourceFunction<T0> source0, SourceFunction<T1> source1) {
        this.type = type;
        this.source0 = source0;
        this.source1 = source1;
        this.terminator = new NeverTerminate();
    }
    
    public void setTerminator(SourceTerminator terminator) {
        this.terminator = terminator;
    }
    
    @Override
    public void setRuntimeContext(RuntimeContext t) {
        super.setRuntimeContext(t);
        
        if (source0 instanceof RichSourceFunction) {
            ((RichSourceFunction<T0>)source0).setRuntimeContext(t);
        }
        
        if (source1 instanceof RichSourceFunction) {
            ((RichSourceFunction<T1>)source1).setRuntimeContext(t);
        }
    }
    
    @Override
    public void open(Configuration parameters) throws Exception {
        super.open(parameters);
        
        if (source0 instanceof RichSourceFunction) {
            ((RichSourceFunction<T0>)source0).open(parameters);
        }
        
        if (source1 instanceof RichSourceFunction) {
            ((RichSourceFunction<T1>)source1).open(parameters);
        }
    }
    
    @Override
    public void initializeState(FunctionInitializationContext context) throws Exception {
        Preconditions.checkArgument(!checkpointed, "The " + getClass().getSimpleName() + " has already been initialized.");

        // Hmm, what does our state actually look like? We really just need to know which
        // source we're processing, and that has to match the state of the source (e.g.
        // instance 0 of source 0 is done, but when state gets redistributed it's no
        // longer done?) I think we'd really need to be able to key off the source
        // functions we're wrapping.

        if (source0 instanceof CheckpointedFunction) {
            ((CheckpointedFunction)source0).initializeState(context);
        }
        
        if (source1 instanceof CheckpointedFunction) {
            ((CheckpointedFunction)source1).initializeState(context);
        }
        
        checkpointed = true;
    }
    
    @Override
    public void snapshotState(FunctionSnapshotContext context) throws Exception {
        Preconditions.checkArgument(checkpointed, "The " + getClass().getSimpleName() + " state has not been properly initialized.");

        if (source0 instanceof CheckpointedFunction) {
            ((CheckpointedFunction)source0).snapshotState(context);
        }
        
        if (source1 instanceof CheckpointedFunction) {
            ((CheckpointedFunction)source1).snapshotState(context);
        }
    }


    @Override
    public void run(final SourceContext<Either<T0, T1>> context) throws Exception {
        isRunning = true;
        sourceId = 0;
        
        SourceContext<T0> s0ctx = new SourceContext<T0>() {

            @Override
            public void collect(T0 element) {
                context.collect(Either.Left(element));
            }

            @Override
            public void collectWithTimestamp(T0 element, long timestamp) {
                context.collectWithTimestamp(Either.Left(element), timestamp);
            }

            @Override
            public void emitWatermark(Watermark mark) {
                context.emitWatermark(mark);
            }

            @Override
            public void markAsTemporarilyIdle() {
                context.markAsTemporarilyIdle();
            }

            @Override
            public Object getCheckpointLock() {
                return context.getCheckpointLock();
            }

            @Override
            public void close() {
                // Ignore, as closing source1 is when we actually want to close
            }
        };
        
        SourceContext<T1> s1ctx = new SourceContext<T1>() {

            @Override
            public void collect(T1 element) {
                context.collect(Either.Right(element));
            }

            @Override
            public void collectWithTimestamp(T1 element, long timestamp) {
                context.collectWithTimestamp(Either.Right(element), timestamp);
            }

            @Override
            public void emitWatermark(Watermark mark) {
                context.emitWatermark(mark);
            }

            @Override
            public void markAsTemporarilyIdle() {
                context.markAsTemporarilyIdle();
            }

            @Override
            public Object getCheckpointLock() {
                return context.getCheckpointLock();
            }

            @Override
            public void close() {
                context.close();
            }
        };
        
        while (isRunning) {
            if (sourceId == 0) {
                LOGGER.info("Running source 0");
                source0.run(s0ctx);
                sourceId += 1;
                
                // TODO delay here is lame, to ensure that the broadcast
                // elements get consumed first.
                Thread.sleep(1000L);
            } else if (sourceId == 1) {
                LOGGER.info("Running source 1");
                source1.run(s1ctx);
                sourceId += 1;
                LOGGER.info("Done with both sources");
            } else if (terminator.isTerminated()) {
                LOGGER.info("Terminating UnionedSources");
                isRunning = false;
            } else {
                Thread.sleep(10L);
            }
        }
    }

    @Override
    public void cancel() {
        isRunning = false;
        
        // Cancel the active source (if any).
        if (sourceId == 0) {
            source0.cancel();
        } else if (sourceId == 1) {
            source1.cancel();
        }
    }

    @Override
    public TypeInformation<Either<T0, T1>> getProducedType() {
        return type;
    }
    
    private static class NeverTerminate extends SourceTerminator {

        @Override
        public boolean isTerminated() {
            return false;
        }
    }
}
